/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package it.unibo.tuprolog.demo.example2


import it.unibo.tuprolog.core.*
import it.unibo.tuprolog.core.List
import it.unibo.tuprolog.core.operators.OperatorSet
import it.unibo.tuprolog.core.parsing.parseAsRule
import it.unibo.tuprolog.core.parsing.parseAsTerm
import kotlin.test.Test
import it.unibo.tuprolog.core.List.Companion as LogicList

@Suppress("USELESS_IS_CHECK")
class HowToManipulateClauses {

    @Test
    fun `one may easily access inner properties for clauses`() {
        val rule = "count([H | L], N) :- count(L, M), N is M + 1".parseAsRule()

        println(rule.head) // count([H_0 | L_0], N_0)
        println(rule.bodySize) // 2
        println(rule.body) // (count(L_0, M_0), is(N_0, '+'(M_0, 1)))
        println(rule.bodyItems.first()) // count(L_0, M_0)
        println(rule.bodyItems.last()) // is(N_0, '+'(M_0, 1))
    }

    @Test
    fun `one may easily get all the variables in a clause`() {
        val rule = "member(X, [_|T]) :- member(X, T)".parseAsRule()

        println(rule.isGround) // false
        println(rule.variables.toSet()) // [X_0, __0, T_0]
    }

    @Test
    fun `one may rewrite clauses by substitutions application`() {
        val rule = "count([H | L], N) :- count(L, M), N is M + 1".parseAsRule()
        val H = rule.variables.first { it.name == "H" }
        val L = rule.variables.first { it.name == "L" }
        val N = rule.variables.first { it.name == "N" }

        val rule1 = rule.apply(
            Substitution.of(
                H to Atom.of("a"),
                L to LogicList.empty(),
                N to Integer.of(1)
            )
        )

        println(rule1) // count([a], 1) :- (count([], M_0), is(1, '+'(M_0, 1)))
        println(rule)  // count([H_0 | L_0], N_0) :- (count(L_0, M_0), is(N_0, '+'(M_0, 1)))
    }
}
